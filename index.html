<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Designer Studio - Space Anomaly</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/3.4.3/gl-matrix-min.js"></script>
    <script src="https://unpkg.com/simplex-noise@3.0.1/simplex-noise.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.skypack.dev/three@0.136.0"
        }
      }
    </script>
</head>
<body>
    <!-- Shader Section -->
    <div class="shader-section">
        <canvas id="canvas"></canvas>
        <textarea id="codeEditor" class="editor" spellcheck="false" autocorrect="off" autocapitalize="off" translate="no" oninput="render()"></textarea>
        <pre id="error"></pre>
        <div id="indicator"></div>
        <div id="controls">
            <div class="controls">
                <input id="btnToggleView" class="icon" type="checkbox" name="toggleView" onclick="toggleView()">
                <input id="btnToggleResolution" class="icon" type="checkbox" name="toggleResolution" onchange="toggleResolution()">
                <input id="btnReset" class="icon" type="checkbox" name="reset" onclick="reset()">
            </div>
        </div>
    </div>

    <script type="x-shader/x-fragment">#version 300 es
/*********
* made by Matthias Hurrle (@atzedent)
*/
precision highp float;
out vec4 O;
uniform float time;
uniform vec2 resolution;
uniform vec2 move;
#define FC gl_FragCoord.xy
#define R resolution
#define T time
#define N normalize
#define S smoothstep
#define MN min(R.x,R.y)
#define rot(a) mat2(cos((a)-vec4(0,11,33,0)))
#define csqr(a) vec2(a.x*a.x-a.y*a.y,2.*a.x*a.y)
float rnd(vec3 p) {
    p=fract(p*vec3(12.9898,78.233,156.34));
    p+=dot(p,p+34.56);
    return fract(p.x*p.y*p.z);
}
float swirls(in vec3 p) {
    float d=.0;
    vec3 c=p;
    for(float i=min(.0,time); i<9.; i++) {
        p=.7*abs(p)/dot(p,p)-.7;
        p.yz=csqr(p.yz);
        p=p.zxy;
        d+=exp(-19.*abs(dot(p,c)));
    }
    return d;
}
vec3 march(in vec3 p, vec3 rd) {
    float d=.2, t=.0, c=.0, k=mix(.9,1.,rnd(rd)),
    maxd=length(p)-1.;
    vec3 col=vec3(0);
    for(float i=min(.0,time); i<120.; i++) {
        t+=d*exp(-2.*c)*k;
        c=swirls(p+rd*t);
        if (t<5e-2 || t>maxd) break;
        col+=vec3(c*c,c/1.05,c)*8e-3;
    }
    return col;
}
float rnd(vec2 p) {
    p=fract(p*vec2(12.9898,78.233));
    p+=dot(p,p+34.56);
    return fract(p.x*p.y);
}
vec3 sky(vec2 p, bool anim) {
    p.x-=.17-(anim?2e-4*T:.0);
    p*=500.;
    vec2 id=floor(p), gv=fract(p)-.5;
    float n=rnd(id), d=length(gv);
    if (n<.975) return vec3(0);
    return vec3(S(3e-2*n,1e-3*n,d*d));
}
void cam(inout vec3 p) {
    p.yz*=rot(move.y*6.3/MN-T*.05);
    p.xz*=rot(-move.x*6.3/MN+T*.025);
}
void main() {
    vec2 uv=(FC-.5*R)/MN;
    vec3 col=vec3(0),
    p=vec3(0,0,-16),
    rd=N(vec3(uv,1)), rdd=rd;
    cam(p); cam(rd);
    col=march(p,rd);
    col=S(-.2,.9,col);
    vec2 sn=.5+vec2(atan(rdd.x,rdd.z),atan(length(rdd.xz),rdd.y))/6.28318;
    col=max(col,vec3(sky(sn,true)+sky(2.+sn*2.,true)));
    float t=min((time-.5)*.3,1.);
    uv=FC/R*2.-1.;
    uv*=.7;
    float v=pow(dot(uv,uv),1.8);
    col=mix(col,vec3(0),v);
    col=mix(vec3(0),col,t);
    col=max(col,.08);
  O=vec4(col,1);
}</script>

    <script src="script.js"></script>
    <script src="footer-script.js"></script>
    <script type="module">
      import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
      
      document.addEventListener('DOMContentLoaded', function() {
        console.log("DOMContentLoaded - starting particle system initialization");
        const particleCanvas = document.getElementById('particleCanvas');
        console.log("Particle canvas element:", particleCanvas);
        if (!particleCanvas) {
          console.error("Particle canvas not found!");
          return;
        }

        let scene, camera, renderer;
        let simulationMaterial, renderMaterial;
        let simulationScene, simulationCamera, renderTarget;
        let particles, wireframeSphere;
        const width = 256, height = 256;

        function getRandomData(width, height, size) {
          const len = width * height * 4;
          const data = new Float32Array(len);
          for (let i = 0; i < len; i += 4) {
            // Start particles in a much larger area
            data[i] = (Math.random() * 2 - 1) * size * 3;     // x
            data[i + 1] = (Math.random() * 2 - 1) * size * 3; // y  
            data[i + 2] = (Math.random() * 2 - 1) * size * 3; // z
            data[i + 3] = Math.random(); // w
          }
          return data;
        }

        function onWindowResize() {
          camera.aspect = particleCanvas.offsetWidth / particleCanvas.offsetHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(particleCanvas.offsetWidth, particleCanvas.offsetHeight);
        }

        function init() {
          console.log("Initializing Three.js scene...");
          console.log("Canvas dimensions:", particleCanvas.offsetWidth, "x", particleCanvas.offsetHeight);
          
          scene = new THREE.Scene();
          camera = new THREE.PerspectiveCamera(75, particleCanvas.offsetWidth / particleCanvas.offsetHeight, 0.1, 1000);
          camera.position.z = 2;

          renderer = new THREE.WebGLRenderer({ canvas: particleCanvas, antialias: true });
          renderer.setSize(particleCanvas.offsetWidth, particleCanvas.offsetHeight);
          renderer.setClearColor(0x000000, 0);
          
          console.log("Three.js renderer initialized");

          simulationScene = new THREE.Scene();
          simulationCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
          renderTarget = new THREE.WebGLRenderTarget(width, height, {
            format: THREE.RGBAFormat,
            type: THREE.FloatType
          });

          const initialPositions = getRandomData(width, height, 1);
          const textureA = new THREE.DataTexture(initialPositions, width, height, THREE.RGBAFormat, THREE.FloatType);
          textureA.needsUpdate = true;

          // Create procedural noise texture instead of loading external image
          const noiseSize = 128;
          const noiseData = new Uint8Array(noiseSize * noiseSize * 4);
          for (let i = 0; i < noiseSize * noiseSize * 4; i += 4) {
            const noise = Math.random();
            noiseData[i] = noise * 255;     // R
            noiseData[i + 1] = noise * 255; // G
            noiseData[i + 2] = noise * 255; // B
            noiseData[i + 3] = 255;         // A
          }
          
          const noiseTexture = new THREE.DataTexture(
            noiseData,
            noiseSize,
            noiseSize,
            THREE.RGBAFormat
          );
          noiseTexture.needsUpdate = true;
          console.log("Procedural noise texture created");

          simulationMaterial = new THREE.ShaderMaterial({
            uniforms: {
              positions: { value: textureA },
              noiseTexture: { value: noiseTexture },
              time: { value: 0 }
            },
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              uniform sampler2D positions;
              uniform sampler2D noiseTexture;
              uniform float time;
              varying vec2 vUv;

              float sdSkull(vec3 p) {
                vec3 q = abs(p);
                float d = length(p - vec3(0.0, 0.15, 0.0)) - 0.6; // Head - larger
                d = min(d, length(p - vec3(0.0, -0.2, 0.25)) - 0.2); // Nose - larger
                d = min(d, length(p - vec3(0.25, -0.05, 0.35)) - 0.15); // Right eye - larger
                d = min(d, length(p - vec3(-0.25, -0.05, 0.35)) - 0.15); // Left eye - larger
                d = min(d, length(max(q - vec3(0.3, -0.45, 0.25), 0.0)) - 0.1); // Jaw - larger
                return d;
              }

              vec3 rotateY(vec3 p, float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);
              }

              void main() {
                vec3 pos = texture2D(positions, vUv).xyz;
                vec3 noise = texture2D(noiseTexture, vUv + time * 0.01).rgb;
                
                // Rotate the skull shape, not the particles
                vec3 skullPos = rotateY(pos, time * 0.2);
                float skull = sdSkull(skullPos);
                
                // Create skull formation - particles closer to skull surface are more visible
                float particleDensity = 1.0 - smoothstep(0.0, 0.3, abs(skull));
                
                // Add some organic movement with noise
                pos += (noise - 0.5) * 0.02;
                
                // Hide particles that are too far from skull shape
                if (abs(skull) > 0.4) {
                  particleDensity = 0.0;
                }

                gl_FragColor = vec4(pos, particleDensity);
              }
            `
          });

          const simulationPlane = new THREE.PlaneGeometry(2, 2);
          const simulationMesh = new THREE.Mesh(simulationPlane, simulationMaterial);
          simulationScene.add(simulationMesh);

          const particleGeometry = new THREE.BufferGeometry();
          const positions = new Float32Array(width * height * 3);
          const uvs = new Float32Array(width * height * 2);

          for (let i = 0; i < width * height; i++) {
            uvs[i * 2] = (i % width) / width;
            uvs[i * 2 + 1] = Math.floor(i / width) / height;
          }

          particleGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
          particleGeometry.setAttribute("uv", new THREE.BufferAttribute(uvs, 2));

          renderMaterial = new THREE.ShaderMaterial({
            uniforms: {
              positionTexture: { value: null },
              pointSize: { value: 8.0 },
              time: { value: 0 }
            },
            vertexShader: `
              uniform sampler2D positionTexture;
              uniform float pointSize;
              uniform float time;
              varying float vOpacity;
              void main() {
                vec4 posData = texture2D(positionTexture, uv);
                vec3 pos = posData.xyz;
                vOpacity = posData.w;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = pointSize * (1.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
              }
            `,
            fragmentShader: `
              varying float vOpacity;
              void main() {
                float r = length(gl_PointCoord - vec2(0.5));
                if (r > 0.5) discard;
                float alpha = smoothstep(0.5, 0.0, r) * vOpacity;
                gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
              }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
          });

          particles = new THREE.Points(particleGeometry, renderMaterial);
          scene.add(particles);
          console.log("Particles added to scene. Particle count:", width * height);

          // Add wireframe sphere
          const sphereGeometry = new THREE.SphereGeometry(0.8, 32, 32);
          const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            wireframe: true,
            transparent: true,
            opacity: 0.6
          });
          wireframeSphere = new THREE.Mesh(sphereGeometry, wireframeMaterial);
          scene.add(wireframeSphere);

          window.addEventListener("resize", onWindowResize);
        }

        function animate() {
          requestAnimationFrame(animate);

          const time = performance.now() * 0.001;

          simulationMaterial.uniforms.time.value = time;
          renderMaterial.uniforms.time.value = time;

          wireframeSphere.rotation.y = time * 0.1;

          renderer.setRenderTarget(renderTarget);
          renderer.render(simulationScene, simulationCamera);
          renderer.setRenderTarget(null);

          renderMaterial.uniforms.positionTexture.value = renderTarget.texture;

          renderer.render(scene, camera);
          
          // Debug log every 60 frames
          if (Math.floor(time * 60) % 60 === 0) {
            console.log("Animation frame rendered, time:", time.toFixed(2));
          }
        }

        init();
        animate();
        
        console.log("Particle system initialized with", width * height, "particles");
      });
    </script>


    <!-- Sticky WebGL container - moved outside footer -->
    <div class="sticky-container" id="stickyContainer">
        <div class="webgl-section" id="webglSection">
            <div class="canvas-container" id="canvasContainer">
                <canvas id="space"></canvas>
                <div class="animated-text" id="animatedText">
                    TRUST YOUR EYES<br />NOT THE NOISE
                </div>
            </div>
        </div>
    </div>

    <!-- Particle Skull Section -->
    <div class="particle-section">
        <canvas id="particleCanvas"></canvas>
        <div class="text-wrapper">
            <h2 class="small-text">Let your intuition lead.</h2>
            <h1 class="text-line">
                Answers lie beneath the surface.<br />
                Trust the whispers of your inner voice.
            </h1>
            <h2 class="small-text">Follow your truth.</h2>
        </div>
    </div>

</body>
</html>